{"ast":null,"code":"var fs = require('fs');\nvar path = require('path');\nvar os = require('os');\nvar packageJson = require('../package.json');\nvar version = packageJson.version;\nvar LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg;\n\n// Parser src into an Object\nfunction parse(src) {\n  var obj = {};\n\n  // Convert buffer to string\n  var lines = src.toString();\n\n  // Convert line breaks to same format\n  lines = lines.replace(/\\r\\n?/mg, '\\n');\n  var match;\n  while ((match = LINE.exec(lines)) != null) {\n    var key = match[1];\n\n    // Default undefined or null to empty string\n    var value = match[2] || '';\n\n    // Remove whitespace\n    value = value.trim();\n\n    // Check if double quoted\n    var maybeQuote = value[0];\n\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2');\n\n    // Expand newlines if double quoted\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, '\\n');\n      value = value.replace(/\\\\r/g, '\\r');\n    }\n\n    // Add to object\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _log(message) {\n  console.log(\"[dotenv@\".concat(version, \"][DEBUG] \").concat(message));\n}\nfunction _resolveHome(envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath;\n}\n\n// Populates process.env from .env file\nfunction config(options) {\n  var dotenvPath = path.resolve(process.cwd(), '.env');\n  var encoding = 'utf8';\n  var debug = Boolean(options && options.debug);\n  var override = Boolean(options && options.override);\n  if (options) {\n    if (options.path != null) {\n      dotenvPath = _resolveHome(options.path);\n    }\n    if (options.encoding != null) {\n      encoding = options.encoding;\n    }\n  }\n  try {\n    // Specifying an encoding returns a string instead of a buffer\n    var parsed = DotenvModule.parse(fs.readFileSync(dotenvPath, {\n      encoding: encoding\n    }));\n    Object.keys(parsed).forEach(function (key) {\n      if (!Object.prototype.hasOwnProperty.call(process.env, key)) {\n        process.env[key] = parsed[key];\n      } else {\n        if (override === true) {\n          process.env[key] = parsed[key];\n        }\n        if (debug) {\n          if (override === true) {\n            _log(\"\\\"\".concat(key, \"\\\" is already defined in `process.env` and WAS overwritten\"));\n          } else {\n            _log(\"\\\"\".concat(key, \"\\\" is already defined in `process.env` and was NOT overwritten\"));\n          }\n        }\n      }\n    });\n    return {\n      parsed: parsed\n    };\n  } catch (e) {\n    if (debug) {\n      _log(\"Failed to load \".concat(dotenvPath, \" \").concat(e.message));\n    }\n    return {\n      error: e\n    };\n  }\n}\nvar DotenvModule = {\n  config: config,\n  parse: parse\n};\nmodule.exports.config = DotenvModule.config;\nmodule.exports.parse = DotenvModule.parse;\nmodule.exports = DotenvModule;","map":{"version":3,"names":["fs","require","path","os","packageJson","version","LINE","parse","src","obj","lines","toString","replace","match","exec","key","value","trim","maybeQuote","_log","message","console","log","concat","_resolveHome","envPath","join","homedir","slice","config","options","dotenvPath","resolve","process","cwd","encoding","debug","Boolean","override","parsed","DotenvModule","readFileSync","Object","keys","forEach","prototype","hasOwnProperty","call","env","e","error","module","exports"],"sources":["D:/cx/node_modules/dotenv/lib/main.js"],"sourcesContent":["const fs = require('fs')\nconst path = require('path')\nconst os = require('os')\nconst packageJson = require('../package.json')\n\nconst version = packageJson.version\n\nconst LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg\n\n// Parser src into an Object\nfunction parse (src) {\n  const obj = {}\n\n  // Convert buffer to string\n  let lines = src.toString()\n\n  // Convert line breaks to same format\n  lines = lines.replace(/\\r\\n?/mg, '\\n')\n\n  let match\n  while ((match = LINE.exec(lines)) != null) {\n    const key = match[1]\n\n    // Default undefined or null to empty string\n    let value = (match[2] || '')\n\n    // Remove whitespace\n    value = value.trim()\n\n    // Check if double quoted\n    const maybeQuote = value[0]\n\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2')\n\n    // Expand newlines if double quoted\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, '\\n')\n      value = value.replace(/\\\\r/g, '\\r')\n    }\n\n    // Add to object\n    obj[key] = value\n  }\n\n  return obj\n}\n\nfunction _log (message) {\n  console.log(`[dotenv@${version}][DEBUG] ${message}`)\n}\n\nfunction _resolveHome (envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath\n}\n\n// Populates process.env from .env file\nfunction config (options) {\n  let dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding = 'utf8'\n  const debug = Boolean(options && options.debug)\n  const override = Boolean(options && options.override)\n\n  if (options) {\n    if (options.path != null) {\n      dotenvPath = _resolveHome(options.path)\n    }\n    if (options.encoding != null) {\n      encoding = options.encoding\n    }\n  }\n\n  try {\n    // Specifying an encoding returns a string instead of a buffer\n    const parsed = DotenvModule.parse(fs.readFileSync(dotenvPath, { encoding }))\n\n    Object.keys(parsed).forEach(function (key) {\n      if (!Object.prototype.hasOwnProperty.call(process.env, key)) {\n        process.env[key] = parsed[key]\n      } else {\n        if (override === true) {\n          process.env[key] = parsed[key]\n        }\n\n        if (debug) {\n          if (override === true) {\n            _log(`\"${key}\" is already defined in \\`process.env\\` and WAS overwritten`)\n          } else {\n            _log(`\"${key}\" is already defined in \\`process.env\\` and was NOT overwritten`)\n          }\n        }\n      }\n    })\n\n    return { parsed }\n  } catch (e) {\n    if (debug) {\n      _log(`Failed to load ${dotenvPath} ${e.message}`)\n    }\n\n    return { error: e }\n  }\n}\n\nconst DotenvModule = {\n  config,\n  parse\n}\n\nmodule.exports.config = DotenvModule.config\nmodule.exports.parse = DotenvModule.parse\nmodule.exports = DotenvModule\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}